# Claude Code Guidelines by Sabrina Ramonov

## Implementation Best Practices

## Project Overview

LION is a Discord bot that tracks activities while offering productivity tools like to-do lists, pomodoro timers, reminders, and statistics. The bot is built with Python using discord.py and PostgreSQL.

### 0 — Purpose  

These rules ensure maintainability, safety, and developer velocity. 
**MUST** rules are enforced by CI; **SHOULD** rules are strongly recommended.

---

### 1 — Before Coding

- **BP-1 (MUST)** Ask the user clarifying questions.
- **BP-2 (SHOULD)** Draft and confirm an approach for complex work.  
- **BP-3 (SHOULD)** If ≥ 2 approaches exist, list clear pros and cons.

---

### 2 — While Coding

- **C-1 (MUST)** Follow TDD: scaffold stub -> write failing test -> implement.
- **C-2 (MUST)** Name functions with existing domain vocabulary for consistency.  
- **C-3 (SHOULD NOT)** Introduce classes when small testable functions suffice.  
- **C-4 (SHOULD)** Prefer simple, composable, testable functions.
- **C-5 (MUST)** Prefer branded `type`s for IDs
  ```ts
  type UserId = Brand<string, 'UserId'>   // ✅ Good
  type UserId = string                    // ❌ Bad
  ```  
- **C-6 (MUST)** Use `import type { … }` for type-only imports.
- **C-7 (SHOULD NOT)** Add comments except for critical caveats; rely on self‑explanatory code.
- **C-8 (SHOULD)** Default to `type`; use `interface` only when more readable or interface merging is required. 
- **C-9 (SHOULD NOT)** Extract a new function unless it will be reused elsewhere, is the only way to unit-test otherwise untestable logic, or drastically improves readability of an opaque block.

---

### 3 — Testing

- **T-1 (MUST)** For a simple function, colocate unit tests in `*.spec.ts` in same directory as source file.
- **T-2 (MUST)** For any API change, add/extend integration tests in `packages/api/test/*.spec.ts`.
- **T-3 (MUST)** ALWAYS separate pure-logic unit tests from DB-touching integration tests.
- **T-4 (SHOULD)** Prefer integration tests over heavy mocking.  
- **T-5 (SHOULD)** Unit-test complex algorithms thoroughly.
- **T-6 (SHOULD)** Test the entire structure in one assertion if possible
  ```ts
  expect(result).toBe([value]) // Good

  expect(result).toHaveLength(1); // Bad
  expect(result[0]).toBe(value); // Bad
  ```

---

### 4 — Database

- **D-1 (MUST)** Type DB helpers as `KyselyDatabase | Transaction<Database>`, so it works for both transactions and DB instances.  
- **D-2 (SHOULD)** Override incorrect generated types in `packages/shared/src/db-types.override.ts`. e.g. autogenerated types show incorrect BigInt value – so we override to `string` manually.

---

### 5 — Code Organization

- **O-1 (MUST)** Place code in `packages/shared` only if used by ≥ 2 packages.

---

### 6 — Tooling Gates

- **G-1 (MUST)** `prettier --check` passes.  
- **G-2 (MUST)** `turbo typecheck lint` passes.  

---

### 7 - Git

- **GH-1 (MUST**) Use Conventional Commits format when writing commit messages: https://www.conventionalcommits.org/en/v1.0.0
- **GH-2 (SHOULD NOT**) Refer to Claude or Anthropic in commit messages.

---

## Writing Functions Best Practices

When evaluating whether a function you implemented is good or not, use this checklist:

1. Can you read the function and HONESTLY easily follow what it's doing? If yes, then stop here.
2. Does the function have very high cyclomatic complexity? (number of independent paths, or, in a lot of cases, number of nesting if if-else as a proxy). If it does, then it's probably sketchy.
3. Are there any common data structures and algorithms that would make this function much easier to follow and more robust? Parsers, trees, stacks / queues, etc.
4. Are there any unused parameters in the function?
5. Are there any unnecessary type casts that can be moved to function arguments?
6. Is the function easily testable without mocking core features (e.g. sql queries, redis, etc.)? If not, can this function be tested as part of an integration test?
7. Does it have any hidden untested dependencies or any values that can be factored out into the arguments instead? Only care about non-trivial dependencies that can actually change or affect the function.
8. Brainstorm 3 better function names and see if the current name is the best, consistent with rest of codebase.

IMPORTANT: you SHOULD NOT refactor out a separate function unless there is a compelling need, such as:
  - the refactored function is used in more than one place
  - the refactored function is easily unit testable while the original function is not AND you can't test it any other way
  - the original function is extremely hard to follow and you resort to putting comments everywhere just to explain it



## Development Commands

### Starting the Bot
- `python scripts/start_leo.py` - Start the main bot
- `python scripts/start_leo_debug.py` - Start bot in debug mode
- `python scripts/start_gui.py` - Start the GUI service
- `python scripts/start_analytics.py` - Start analytics service
- `python scripts/start_registry.py` - Start registry service

### Database Setup
- Install PostgreSQL and create database using schema in `data/schema.sql`
- Copy `config/example-bot.conf` to `config/bot.conf` with your database connection details
- Copy `config/example-secrets.conf` to `config/secrets.conf` with bot tokens

### Localization
- `./scripts/makestrings.sh` - Generate translation templates from source code
- `python scripts/makedomains.py` - Create domain files for translations

### Dependencies
- `pip install -r requirements.txt` - Install Python dependencies

## Architecture

### Core Components

**Bot Entry Point**: `src/bot.py` - Main bot initialization and startup
**Meta Framework**: `src/meta/` - Core bot framework including:
- `LionBot.py` - Main bot class extending discord.py
- `config.py` - Configuration management system
- `logger.py` - Logging infrastructure
- `sharding.py` - Bot sharding support

**Data Layer**: `src/data/` - Database abstraction layer with:
- `database.py` - Main database connection and registry management
- `models.py` - Base model classes for database rows
- `registry.py` - Registry system for organizing data models
- `connector.py` - PostgreSQL connection handling

**Module System**: `src/modules/` - Feature modules as Discord cogs:
- Each module is a self-contained feature (e.g., `pomodoro/`, `statistics/`, `economy/`)
- Modules follow pattern: `cog.py` (Discord cog), `data.py` (database models), `ui/` (user interfaces)

### Key Patterns

**Configuration**: Uses ConfigParser format in `config/` directory. Main config sections:
- `[STUDYLION]` - Bot settings (prefix, admins, shards)
- `[DATABASE]` - Database connection parameters (in secrets.conf)
- `[BABEL]` - Internationalization settings

**Database Models**: Uses custom ORM with Registry pattern:
- Models inherit from `RowModel` 
- Registries group related models (e.g., `CoreData`, `EconomyData`)
- Automatic table binding and query generation

**UI Components**: Uses discord.py Views and Modals for interactive elements:
- Complex UIs are in module `ui/` subdirectories
- Follows naming pattern: `*ui.py` for UI classes

**Internationalization**: Full i18n support via babel:
- Translation files in `locales/` with gettext `.po` format
- Domain-based organization matching module structure
- Context-aware translation with `ctx_translator`


## Remember Shortcuts

Remember the following shortcuts which the user may invoke at any time.

### QNEW

When I type "qnew", this means:

```
Understand all BEST PRACTICES listed in CLAUDE.md.
Your code SHOULD ALWAYS follow these best practices.
```

### QPLAN
When I type "qplan", this means:
```
Analyze similar parts of the codebase and determine whether your plan:
- is consistent with rest of codebase
- introduces minimal changes
- reuses existing code
```

## QCODE

When I type "qcode", this means:

```
Implement your plan and make sure your new tests pass.
Always run tests to make sure you didn't break anything else.
Always run `prettier` on the newly created files to ensure standard formatting.
Always run `turbo typecheck lint` to make sure type checking and linting passes.
```

### QCHECK

When I type "qcheck", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR code change you introduced (skip minor changes):

1. CLAUDE.md checklist Writing Functions Best Practices.
2. CLAUDE.md checklist Writing Tests Best Practices.
3. CLAUDE.md checklist Implementation Best Practices.
```

### QCHECKF

When I type "qcheckf", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR function you added or edited (skip minor changes):

1. CLAUDE.md checklist Writing Functions Best Practices.
```

### QCHECKT

When I type "qcheckt", this means:

```
You are a SKEPTICAL senior software engineer.
Perform this analysis for every MAJOR test you added or edited (skip minor changes):

1. CLAUDE.md checklist Writing Tests Best Practices.
```

### QUX

When I type "qux", this means:

```
Imagine you are a human UX tester of the feature you implemented. 
Output a comprehensive list of scenarios you would test, sorted by highest priority.
```

### QGIT

When I type "qgit", this means:

```
Add all changes to staging, create a commit, and push to remote.

Follow this checklist for writing your commit message:
- SHOULD use Conventional Commits format: https://www.conventionalcommits.org/en/v1.0.0
- SHOULD NOT refer to Claude or Anthropic in the commit message.
- SHOULD structure commit message as follows:
<type>[optional scope]: <description>
[optional body]
[optional footer(s)]
- commit SHOULD contain the following structural elements to communicate intent: 
fix: a commit of the type fix patches a bug in your codebase (this correlates with PATCH in Semantic Versioning).
feat: a commit of the type feat introduces a new feature to the codebase (this correlates with MINOR in Semantic Versioning).
BREAKING CHANGE: a commit that has a footer BREAKING CHANGE:, or appends a ! after the type/scope, introduces a breaking API change (correlating with MAJOR in Semantic Versioning). A BREAKING CHANGE can be part of commits of any type.
types other than fix: and feat: are allowed, for example @commitlint/config-conventional (based on the Angular convention) recommends build:, chore:, ci:, docs:, style:, refactor:, perf:, test:, and others.
footers other than BREAKING CHANGE: <description> may be provided and follow a convention similar to git trailer format.
```

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

## Additional Architecture Notes

### Testing Framework
The project uses custom testing through `tests/gui/` for GUI card generation:
- Test files generate sample images for skin validation (`tests/gui/cards/*_sample.py`)
- Tests are primarily focused on visual components and skin rendering
- No standard pytest/unittest framework detected - testing is specialized for Discord bot graphics

### Skins System
Advanced theming system in `skins/`:
- JSON-based skin definitions with asset references
- Multiple built-in themes (base, obsidian, platinum, bubblegum, etc.)
- Custom skin editor for premium users in `src/modules/skins/editor/`
- Supports fonts, images, and color customization
- Mixins system for shared skin components

### GUI Generation System
Sophisticated graphics rendering in `src/gui/`:
- Card-based system for generating user statistics images
- PIL-based rendering with custom `Card` class in `src/gui/base/`
- Specialized cards for profiles, leaderboards, timers, etc. in `src/gui/cards/`
- Avatar handling and masking system
- Font management with multiple language support

### Core Framework Patterns
**Registry System**: Custom database abstraction using registries (`src/data/registry.py`):
- Groups related database models together
- Automatic binding to database connections
- Each module can have its own data registry

**Cog Architecture**: Discord.py cogs with LionCog base class:
- Each feature module has a `cog.py` file extending `LionCog`
- Standardized patterns for commands, events, and UI interactions
- Settings integration for per-guild configuration

**Context System**: Enhanced Discord context with `LionContext`:
- Extended context for better user/guild handling
- Integration with the Lions cache system
- Automatic translation support

### Configuration System
**Multi-file Configuration**:
- `config/bot.conf` - Main bot settings
- `config/secrets.conf` - Sensitive data (tokens, database credentials)
- `config/emojis.conf` - Custom emoji mappings
- `config/gui.conf` - GUI service configuration

### Important Python-Specific Notes
Since the existing guidelines reference TypeScript patterns, note that this is a **Python Discord bot**:
- Uses `discord.py` library, not discord.js
- PostgreSQL with custom ORM, not Kysely
- Uses Python async/await patterns
- Module imports follow Python conventions
- Database schema in SQL format (`data/schema.sql`)

### Development Workflow
**Database Migrations**: Version-controlled schema updates in `data/migration/`:
- Sequential version folders (v0-v1, v1-v2, etc.)
- Each migration includes SQL files and notes
- Version tracking in `VersionHistory` table

**Internationalization Workflow**:
- Extract translatable strings with `./scripts/makestrings.sh`
- Generate domain files with `python scripts/makedomains.py`
- Translation files in `locales/` organized by language and domain

### Deployment Notes
- **Environment Setup**: all requirements are met when bot is launched in activated venv